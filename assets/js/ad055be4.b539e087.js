"use strict";(self.webpackChunkwi_znet_documentation=self.webpackChunkwi_znet_documentation||[]).push([[57543],{3905:function(e,n,t){t.d(n,{Zo:function(){return d},kt:function(){return T}});var i=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,i,r=function(e,n){if(null==e)return{};var t,i,r={},s=Object.keys(e);for(i=0;i<s.length;i++)t=s[i],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(i=0;i<s.length;i++)t=s[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=i.createContext({}),l=function(e){var n=i.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},d=function(e){var n=l(e.components);return i.createElement(c.Provider,{value:n},e.children)},S={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},u=i.forwardRef((function(e,n){var t=e.components,r=e.mdxType,s=e.originalType,c=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),u=l(t),T=r,p=u["".concat(c,".").concat(T)]||u[T]||S[T]||s;return t?i.createElement(p,a(a({ref:n},d),{},{components:t})):i.createElement(p,a({ref:n},d))}));function T(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var s=t.length,a=new Array(s);a[0]=u;var o={};for(var c in n)hasOwnProperty.call(n,c)&&(o[c]=n[c]);o.originalType=e,o.mdxType="string"==typeof e?e:r,a[1]=o;for(var l=2;l<s;l++)a[l]=t[l];return i.createElement.apply(null,a)}return i.createElement.apply(null,t)}u.displayName="MDXCreateElement"},39512:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return o},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return d},default:function(){return u}});var i=t(83117),r=t(80102),s=(t(67294),t(3905)),a=["components"],o={id:"tcp",title:"W5100S TCP Function",date:new Date("2020-04-03T00:00:00.000Z")},c=void 0,l={unversionedId:"Product/iEthernet/W5100S/Application-Note/tcp",id:"Product/iEthernet/W5100S/Application-Note/tcp",isDocsHomePage:!1,title:"W5100S TCP Function",description:"By setting some Registers and Memory Operation, W5100S provides Internet",source:"@site/docs/Product/iEthernet/W5100S/Application-Note/TCP.md",sourceDirName:"Product/iEthernet/W5100S/Application-Note",slug:"/Product/iEthernet/W5100S/Application-Note/tcp",permalink:"/document_framework/Product/iEthernet/W5100S/Application-Note/tcp",editUrl:"https://github.com/Wiznet/document_framework/tree/master/docs/Product/iEthernet/W5100S/Application-Note/TCP.md",tags:[],version:"current",frontMatter:{id:"tcp",title:"W5100S TCP Function",date:"2020-04-03T00:00:00.000Z"},sidebar:"docs",previous:{title:"W5100S Application",permalink:"/document_framework/Product/iEthernet/W5100S/Application-Note/w5100s_application"},next:{title:"W5100S UDP Function",permalink:"/document_framework/Product/iEthernet/W5100S/Application-Note/udp"}},d=[{value:"Initialization",id:"initialization",children:[{value:"Basic Setting",id:"basic-setting",children:[],level:3},{value:"Setting Network Information",id:"setting-network-information",children:[],level:3},{value:"Set SOCKET n Buffer Information",id:"set-socket-n-buffer-information",children:[],level:3}],level:2},{value:"Data Communications",id:"data-communications",children:[{value:"TCP",id:"tcp",children:[],level:3},{value:"TCP SERVER",id:"tcp-server",children:[{value:"SOCKET Initialization",id:"socket-initialization",children:[],level:4},{value:"LISTEN",id:"listen",children:[],level:4},{value:"ESTABLISHMENT",id:"establishment",children:[],level:4},{value:"Receive DATA?",id:"receive-data",children:[],level:4},{value:"LISTEN",id:"listen-1",children:[],level:4},{value:"ESTABLISHMENT",id:"establishment-1",children:[],level:4},{value:"Receive DATA?",id:"receive-data-1",children:[],level:4},{value:"Receiving Process",id:"receiving-process",children:[],level:4},{value:"Send DATA? / Sending Process",id:"send-data--sending-process",children:[],level:4},{value:"Received FIN (Passive Close)",id:"received-fin-passive-close",children:[],level:4},{value:"Disconnected (Active Close)",id:"disconnected-active-close",children:[],level:4},{value:"Disconnecting Process",id:"disconnecting-process",children:[],level:4},{value:"Timeout?",id:"timeout",children:[],level:4},{value:"CLOSE",id:"close",children:[],level:4}],level:3},{value:"TCP CLIENT",id:"tcp-client",children:[{value:"OPEN",id:"open",children:[{value:"CONNECT",id:"connect",children:[],level:5}],level:4},{value:"ESTABLISHED?",id:"established",children:[],level:4},{value:"Others flow",id:"others-flow",children:[],level:4}],level:3}],level:2}],S={toc:d};function u(e){var n=e.components,o=(0,r.Z)(e,a);return(0,s.kt)("wrapper",(0,i.Z)({},S,o,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"By setting some Registers and Memory Operation, W5100S provides Internet\nConnectivity. This Chapter describes How to operate W5100S TCP Function."),(0,s.kt)("h2",{id:"initialization"},"Initialization"),(0,s.kt)("h3",{id:"basic-setting"},"Basic Setting"),(0,s.kt)("p",null,"For W5100S Operation, select and utilize appropriate Registers shown\nbelow."),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"Mode Register (MR)"),(0,s.kt)("li",{parentName:"ol"},"Interrupt Mask Register (IMR)"),(0,s.kt)("li",{parentName:"ol"},"Retry Time-value Register (RTR)"),(0,s.kt)("li",{parentName:"ol"},"Retry Count Register (RCR)")),(0,s.kt)("p",null,"For more Information of above Registers, refer to the \u201cRegister\nDescriptions\u201d in ",(0,s.kt)("a",{parentName:"p",href:"../document"},"W5100S Datasheet"),"."),(0,s.kt)("h3",{id:"setting-network-information"},"Setting Network Information"),(0,s.kt)("p",null,"Basic Network Information setting for Communication: It must be set the\nbasic Network Information."),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"SHAR(Source Hardware Address Register)",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"It is prescribed that the Source Hardware Addresses, which is\nset by SHAR, use unique Hardware Addresses (Ethernet MAC\naddress) in the Ethernet MAC Layer. The IEEE manages the MAC\naddress allocation. The manufacturer which produces the Network\ndevice allocates the MAC Address to product."),(0,s.kt)("li",{parentName:"ul"},"Details on MAC address allocation refer to the website as below."),(0,s.kt)("li",{parentName:"ul"},"\ud83c\udf0e",(0,s.kt)("a",{parentName:"li",href:"http://www.ieee.org/"},"http://www.ieee.org/")),(0,s.kt)("li",{parentName:"ul"},"\ud83c\udf0e",(0,s.kt)("a",{parentName:"li",href:"http://standards.ieee.org/regauth/oui/index.shtml"},"http://standards.ieee.org/regauth/oui/index.shtml")))),(0,s.kt)("li",{parentName:"ol"},"GAR(Gateway Address Register)"),(0,s.kt)("li",{parentName:"ol"},"SUBR(Subnet Mask Register)"),(0,s.kt)("li",{parentName:"ol"},"SIPR(Source IP Address Register)")),(0,s.kt)("h3",{id:"set-socket-n-buffer-information"},"Set SOCKET n Buffer Information"),(0,s.kt)("p",null,"This stage shows SOCKET n TX/RX Buffer Information. The base Address and\nMask Address of each SOCKET are set in this stage."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"*In case of, assign 2KB TX/RX Buffer per SOCKET")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},"In case of, assign 2KB TX/RX Buffer per SOCKET\n{\n   // set Base Address of TX/RX Buffer for SOCKET n\n   gS0_RX_BASE = 0x8000; // TX Buffer Block Base Address\n   gS0_RX_BASE = 0xC000; // RX Buffer Block Base Address\n   TxTotalSize = 0; // For check the total size of SOCKET n TX Buffer\n   RxTotalSize = 0; // For check the total size of SOCKET n RX Buffer\n   \n   for (n=0; n<3; n++) {\n      Sn_TXBUF_SIZE = 2; // assign 2KB TX Buffer per SOCKET\n      Sn_RXBUF_SIZE = 2; // assign 2KB RX Buffer per SOCKET\n      // 0x07FF, for getting offset address within assigned SOCKET n TX/RX Buffer\n      gSn_TX_MASK = (1024 * Sn_TXBUF_SIZE) \u2013 1;\n      gSn_RX_MASK = (1024 * Sn_RXBUF_SIZE) - 1;\n      \n      if( n != 0) {\n         gSn_TX_BASE = gSn-1_TX_BASE + (1024 * Sn-1_TXBUF_SIZE);\n         gSn_RX_BASE = gSn-1_RX_BASE + (1024 * Sn-1_RXBUF_SIZE);\n      } // end if\n      \n   TxTotalSize = TxTotalSize + Sn_TXBUF_SIZE;\n   RxTotalSize = RxTotalSize + Sn_RXBUF_SIZE;\n   If( TxTotalSize > 8 or RxTotalSize > 8 ) goto ERROR; // invalid Total Size\n   } // end for\n}\n")),(0,s.kt)("h2",{id:"data-communications"},"Data Communications"),(0,s.kt)("p",null,"After Initialization Process, SOCKET is opened on TCP, UDP, IPRAW or\nMACRAW Mode and able to transmit and receive Data. This stage shows How\nto use SOCKET on TCP Mode."),(0,s.kt)("h3",{id:"tcp"},"TCP"),(0,s.kt)("p",null,"TCP (Transmission Control Protocol) is a bidirectional Data Transmission\nProtocol based on a 1:1 communication on Transport Layer. It also\nprovides Communication between Applications by using Port Number. TCP\n1:1 communication needs the Connection Process such as transmitting\nConnection Request to Peer or receiving Connection Request from Peer. In\nthis Connection Process, the side transmitting Connection Request is\n\u2018TCP CLIENT\u2019 and the other side receiving Connection Request is \u2018TCP\nSERVER\u2019. TCP also provides reliable, ordered and error-checked delivery\nof a stream Data between applications running on hosts communicating by\nan IP network. \u2018TCP SERVER\u2019 and \u2018TCP CLIENT\u2019 are maintaining transmit\nand receive Data until the TCP connection is terminated. ",(0,s.kt)("img",{alt:"TCP SERVER and TCP CLIENT",src:t(94024).Z})),(0,s.kt)("h3",{id:"tcp-server"},"TCP SERVER"),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"TCP SERVER Operation Flow",src:t(43793).Z})),(0,s.kt)("h4",{id:"socket-initialization"},"SOCKET Initialization"),(0,s.kt)("p",null,"SOCKET Initialization is required for TCP Mode SOCKET. The\nInitialization consists of SOCKET Mode setting, SOCKET Port Number\nsetting, SOCKET Option setting and SOCKET OPEN Command. 4 SOCKETs are\nall opened as TCP Mode. After OPEN Command(Sn","_","CR = OPEN), if the SOCKET\nstatus(Sn","_","SR) is changed to SOCKET","_",'INIT, SOCKET Initialization is\ncompleted. This process is identically applied in "TCP SERVER" and "TCP\nCLIENT".'),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},"{\nSTART:\n\n   Sn_MR[3:0] = \"0001\"; // set TCP Mode\n   Sn_PORTR0,1 = source_port; // sets source port number\n\n   /* configure SOCKET Option when you need it */\n   // Sn_MR[ND] = '1'; // set No Delay ACK\n\n   Sn_CR = OPEN; // sets OPEN command\n   /* wait until Sn_SR is changed to SOCK_INIT */\n   if (Sn_SR != SOCK_INIT) Sn_CR = CLOSE; goto START;\n}\n")),(0,s.kt)("h4",{id:"listen"},"LISTEN"),(0,s.kt)("p",null,"Run as \u201cTCP SERVER\u201d by LISTEN Command."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},"{\n   /* listen SOCKET */\n   Sn_CR = LISTEN;\n   /* wait until Sn_SR is changed to SOCK_LISTEN */\n   if (Sn_SR != SOCK_LISTEN) Sn_CR = CLOSE; goto START;\n}\n")),(0,s.kt)("h4",{id:"establishment"},"ESTABLISHMENT"),(0,s.kt)("p",null,'"TCP SERVER" keeps Sn',"_","SR (SOCK","_",'LISTEN) until received SYN Packet. If\n"TCP SERVER" receives SYN Packet from "TCP CLIENT", it transmits SYN/ACK\nPacket to \u2018TCP CLIENT\u2019 and the Connection Process between "TCP SERVER"\nand "TCP CLIENT" is completed. If there is no response from Peer against\nof transmitted SYN Packet or SYN/ACK Packet within the Retransmission\nTime, Sn',"_","IR ","[","TIMEOUT","]"," is set to \u20181\u2019."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},"First method :\n{\n   /* check SOCKET Interrupt */\n   if (Sn_IR[CON] == \u20181\u2019)\n   {\n      /* clear SOCKET Interrupt */\n      Sn_IR[CON] = \u20181\u2019;\n      goto Received DATA?; /* or goto Send DATA?; */\n   }\n   else if(Sn_IR[TIMEOUT] == \u20181\u2019) goto Timeout?;\n}\n\nSecond method :\n{\n   if (Sn_SR == SOCK_ESTABLISHED)\n   {\n      /* clear SOCKET Interrupt */\n      Sn_IR[CON] = \u20181\u2019;\n      goto Received DATA? /* or goto Send DATA?; */\n   }\n   else if(Sn_IR[TIMEOUT] == \u20181\u2019) goto Timeout?;\n}\n")),(0,s.kt)("h4",{id:"receive-data"},"Receive DATA?"),(0,s.kt)("p",null,"Whether SOCKET n Data is received is confirmed by Sn","_","IR ","[","RECV","]"," or\nSn","_","RX","_","RSR."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},"First method :\n{\n   /* check SOCKET RX Memory Received Size */\n   if (Sn_RX_RSR > 0) goto Receiving Process;\n}\n\nSecond method :\n{\n   if (Sn_IR[RECV] == \u20181\u2019)\n   {\n      /* check SOCKET Interrupt */\n      Sn_IR[RECV] = \u20181\u2019; /* clear SOCKET Interrupt */\n      goto Receiving Process;\n   }\n}\n")),(0,s.kt)("h4",{id:"listen-1"},"LISTEN"),(0,s.kt)("p",null,"Run as \u201cTCP SERVER\u201d by LISTEN Command."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},"{\n   /* listen SOCKET */\n   Sn_CR = LISTEN;\n   /* wait until Sn_SR is changed to SOCK_LISTEN */\n   if (Sn_SR != SOCK_LISTEN) Sn_CR = CLOSE; goto START;\n}\n")),(0,s.kt)("h4",{id:"establishment-1"},"ESTABLISHMENT"),(0,s.kt)("p",null,'"TCP SERVER" keeps Sn',"_","SR (SOCK","_",'LISTEN) until received SYN Packet. If\n"TCP SERVER" receives SYN Packet from "TCP CLIENT", it transmits SYN/ACK\nPacket to \u2018TCP CLIENT\u2019 and the Connection Process between "TCP SERVER"\nand "TCP CLIENT" is completed. If there is no response from Peer against\nof transmitted SYN Packet or SYN/ACK Packet within the Retransmission\nTime, Sn',"_","IR ","[","TIMEOUT","]"," is set to \u20181\u2019."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},"First method :\n{\n   /* check SOCKET Interrupt */\n   if (Sn_IR[CON] == \u20181\u2019)\n   {\n      /* clear SOCKET Interrupt */\n      Sn_IR[CON] = \u20181\u2019;\n      goto Received DATA?; /* or goto Send DATA?; */\n   }\n   else if(Sn_IR[TIMEOUT] == \u20181\u2019) goto Timeout?;\n}\n\nSecond method :\n{\n   if (Sn_SR == SOCK_ESTABLISHED)\n   {\n      /* clear SOCKET Interrupt */\n      Sn_IR[CON] = \u20181\u2019;\n      goto Received DATA? /* or goto Send DATA?; */\n   }\n   else if(Sn_IR[TIMEOUT] == \u20181\u2019) goto Timeout?;\n}\n")),(0,s.kt)("h4",{id:"receive-data-1"},"Receive DATA?"),(0,s.kt)("p",null,"Whether SOCKET n Data is received is confirmed by Sn","_","IR ","[","RECV","]"," or\nSn","_","RX","_","RSR."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},"First method :\n{\n   /* check SOCKET RX Memory Received Size */\n   if (Sn_RX_RSR > 0) goto Receiving Process;\n}\n\nSecond method :\n{\n   if (Sn_IR[RECV] == \u20181\u2019)\n   {\n      /* check SOCKET Interrupt */\n      Sn_IR[RECV] = \u20181\u2019; /* clear SOCKET Interrupt */\n      goto Receiving Process;\n   }\n}\n")),(0,s.kt)("h4",{id:"receiving-process"},"Receiving Process"),(0,s.kt)("p",null,"Received Data is read from SOCKET n RX Buffer Block. The Read Offset\nAddress of Received Data in RX Memory Block is calculated by\ngSn","_","RX","_","BASE, gSn","_","RX","_","MASK and Sn","_","RX","_","RD. After reading received\nData, Sn","_","RX","_","RD must be increased by Data read Size and Sn","_","CR ","[","RECV","]","\nmust be set to \u20181\u2019. If there is remain Data in SOCKET n RX Buffer Block\nafter Sn","_","CR ","[","RECV","]"," Command, Sn","_","IR ","[","RECV","]"," is set to \u20181\u2019. When Read\nOffset Address calculated, it is cautious to over the boundary Address\n(n=0,1,2 : gSn","_","RX","_","BASE \u223c gSn+1","_","RX","_","BASE, n=3 : gS3","_","RX","_","BASE \u223c\n0xFFFF) of SOCKET n RX Buffer Block."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},"{\n   /* get Received Size */\n   get_size = Sn_RX_RSR;\n\n   /* calculate SOCKET n RX Buffer Size & Offset Address */\n   gSn_RX_MAX = Sn_RXBUF_SIZE * 1024;\n   get_offset = Sn_RX_RD & gSn_RX_MASK;\n\n   /* calculate Read Offset Address */\n   get_start_address = gSn_RX_BASE + get_offset;\n   \n   /* if overflow the upper boundary of SOCKET n RX Buffer */\n   If( (get_offset + get_size) > gSn_RX_MAX )\n   {\n      /* copy upper_size bytes of get_start_address to destination_address\n         - destination_address is user data memory address */\n      upper_size = gSn_RX_MAX \u2013 get_offset;\n      memcpy(get_start_address, destination_address, upper_size);\n      destination_address += upper_size;\n      /* copy the remained size bytes of gSn_RX_BASE to destination_address */\n      remained_size = get_size \u2013 upper_size;\n      memcpy(gSn_RX_BASE, destination_address, remained_size);\n   }\n   else\n   {\n      /* copy get_size of get_start_address to destination_address */\n      memcpy(get_start_address, destination_address, get_size);\n   }\n   \n   /* increase Sn_RX_RD as get_size */\n   Sn_RX_RD += get_size;\n   \n   /* set RECV Command */\n   Sn_CR[RECV] = \u20181\u2019;\n   while(Sn_CR != 0x00); /* wait until RECV Command is cleared*/\n}\n")),(0,s.kt)("h4",{id:"send-data--sending-process"},"Send DATA? / Sending Process"),(0,s.kt)("p",null,"Written Data in SOCKET n TX Buffer Block is transmitted. The Write\nOffset Address in TX Memory Block is calculated by gSn","_","TX","_","BASE,\ngSn","_","TX","_","MASK and Sn","_","TX","_","WD. And Data to be transmitted from the Write\nOffset Address is written. After writing Data, Sn","_","TX","_","WD must be\nincreased by Data Size and Data is transmitted by Sn","_","CR ","[","SEND","]",".\nBefore Sn","_","IR ","[","SENDOK","]"," = \u20181\u2019, next Data Transmission Process is not\nexecuted. After transmitting Data, the time length until\nSn","_","IR","[","SENDOK","]"," is depending on SOCKET Count, Data Size and Network\nTraffic. Also Sn","_","IR ","[","TIMEOUT","]"," could be occurred. When Write Offset\nAddress calculated, it is cautious to over the boundary Address (n=0,1,2\n: gSn","_","TX","_","BASE \u223c gSn+1","_","TX","_","BASE, n=3 : gS3","_","TX","_","BASE \u223c 0xC000) of\nSOCKET n TX Buffer Block. If there is no response from Peer against of\ntransmitted Data Packet within the Retransmission Time, Sn","_","IR\n","[","TIMEOUT","]"," is set to \u20181\u2019."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},"{\n   /* calculate SOCKETn TX Buffer Size & Offset Address */\n   gSn_TX_MAX = Sn_TXBUF_SIZE * 1024;\n   get_offset = Sn_TX_WR & gSn_TX_MASK;\n   \n   /* check the max size of DATA(send_size) & Free Size of SOCKETn TX\n      Buffer(Sn_TX_FSR)*/\n   if( send_size >gSn_TX_MAX ) send_size = gSn_TX_MAX;\n   while(send <= Sn_TX_FSR); // Wait until SOCKET n TX Buffer is free */\n\n   /* If you don\u2019t want to wait TX Buffer Free\n      send_size = Sn_TX_FSR; // write Data as size of Free Buffer */\n   /* calculate Write Offset Address */\n   get_start_address = gSn_TX_BASE + get_offset;\n   \n   /* if overflow the upper boundary of SOCKET n TX Buffer */\n   If( (get_offset + send_size) > gSn_TX_MAX )\n   {\n      /* copy upper size bytes of source_address to get_start_address\n         - source_address is the start address of user data */\n      upper_size = gSn_TX_MAX \u2013 get_offset;\n      memcpy(source_address, get_start_address, upper_size);\n      \n      /* copy the Remained Size Bytes of source_address to gSn_TX_BASE */\n      source_address += upper_size;\n      remained_size = send_size \u2013 upper_size;\n      memcpy(source_address, gSn_TX_BASE, remained_size);\n   }\n   else\n   {\n      /* copy send_size bytes of source_address to get_start_address\n         - source_address is the start address of user data */\n      memcpy(source_address, get_start_address, send_size);\n   }\n   \n   /* increase Sn_TX_WR as send_size */\n   Sn_TX_WR += send_size;\n   \n   /* set SEND Command */\n   Sn_CR = SEND;\n   while(Sn_CR != 0x00); /* wait until SEND Command is cleared*/\n   \n   /* wait until SEND Command is completed or TIMEOUT Interrupt is occurred*/\n   while(Sn_IR[SENDOK] == \u20180\u2019 and Sn_IR[TIMEOUT] = \u20180\u2019);\n   \n   /* clear SOCKET Interrupt*/\n   if(Sn_IR[SENDOK] == \u20181\u2019) Sn_IR[SENDOK] = \u20181\u2019;\n   else goto Timeout?;\n}\n")),(0,s.kt)("h4",{id:"received-fin-passive-close"},"Received FIN (Passive Close)"),(0,s.kt)("p",null,"When FIN Packet received from Peer."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},"First Method:\n{\n   If(Sn_SR == SOCK_CLOSE_WAIT) goto Disconnecting Process;\n}\n\nSecond Method:\n{\n   If(Sn_IR[DISCON] == \u20181\u2019) goto Disconnecting Process;\n}\n")),(0,s.kt)("h4",{id:"disconnected-active-close"},"Disconnected (Active Close)"),(0,s.kt)("p",null,"When FIN Packet transmitted to Peer."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},"{\n   /* send FIN Packet */\n   Sn_CR[DISCON] = \u20181\u2019;\n   while(Sn_CR != 0x00); /* wait until DISCON Command is cleared*/\n   goto Disconnecting Process;\n}\n")),(0,s.kt)("h4",{id:"disconnecting-process"},"Disconnecting Process"),(0,s.kt)("p",null,"In Passive Close, if FIN Packet is received from Peer and there is no\nData to be transmitted, SOCKET transmits FIN Packet and it will be\nclosed. If there is no response from Peer against of transmitted FIN\nPacket within the Retransmission Time, Sn","_","IR ","[","TIMEOUT","]"," is set to \u20181\u2019.\nIn Active Close, if SOCKET transmits FIN Packet to Peer, SOCKET waits\nfor Peer FIN Packet. SOCKET will be closed after receiving FIN Packet\nfrom Peer. If there is no response from Peer against of transmitted FIN\nPacket within the Retransmission Time, Sn","_","IR ","[","TIMEOUT","]"," is set to \u20181\u2019."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},"Passive Close: /* received FIN Packet from Peer */\n{\n   /* send FIN Packet */\n   Sn_CR = DISCON;\n   while(Sn_CR != 0x00); /* wait until DISCON Command is cleared*/\n\n   /* wait unit ACK Packet is received*/\n   while(Sn_IR[DISCON] == \u20180\u2019 and Sn_IR[TIMEOUT] == \u20180\u2019) ;\n   if (Sn_IR[DISCON] == \u20181\u2019)\n   {\n      /* clear Interrupt */\n      Sn_IR[DISCON] = \u20181\u2019;\n      goto CLOSED;\n   }\n   else goto Timeout?;\n}\n\nActive Close : /* sent FIN Packet to Peer */\n{\n   /* wait until FIN Packet is received*/\n   while(Sn_IR[DISCON] == \u20180\u2019 and Sn_IR[TIMEOUT] == \u20180\u2019) ;\n   if (Sn_IR[DISOCN] == \u20181\u2019)\n   {\n      /* clear Interrupt */\n      Sn_IR[DISCON] = \u20181\u2019;\n      goto CLOSED;\n   }\n   else goto Timeout?;\n}\n")),(0,s.kt)("h4",{id:"timeout"},"Timeout?"),(0,s.kt)("p",null,"If there is no response from Peer against of transmitted SYN or SYN/ACK\nor FIN or Data Packet within the Retransmission Time, Sn","_","IR ","[","TIMEOUT","]","\nis set to \u20181\u2019."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},"{\n   /* check TIMEOUT Interrupt */\n   if(Sn_IR[TIMEOUT] == \u20181\u2019)\n   {\n      /* clear Interrupt */\n      Sn_IR[TIMEOUT] = \u20181\u2019;\n      goto CLOSE;\n   }\n}\n")),(0,s.kt)("h4",{id:"close"},"CLOSE"),(0,s.kt)("p",null,"SOCKET n is closed by the Disconnect Process, Sn","_","IR","[","TIMEOUT","]"," = '1'\nand Sn","_","CR","[","CLOSE","]"," = '1'."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},"{\n   /*wait until SOCKET n is closed*/\n   while(Sn_SR != SOCK_CLOSED);\n}\n")),(0,s.kt)("h3",{id:"tcp-client"},"TCP CLIENT"),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"TCP CLIENT Operation Flow",src:t(4944).Z})),(0,s.kt)("h4",{id:"open"},"OPEN"),(0,s.kt)("p",null,'It is the same as "TCP SERVER".'),(0,s.kt)("h5",{id:"connect"},"CONNECT"),(0,s.kt)("p",null,'SOCKET n is operated as "TCP CLIENT" by Sn',"_","CR","[","CONNECT","]",'. SYN Packet is\ntransmitted to "TCP SERVER" by Sn',"_","CR","[","CONNECT","]","."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},"{\n   /* set Destination IP Address, 192.168.0.11 */\n   Sn_DIPR[0:3] ={ 0xC0, 0xA8, 0x00, 0x0B};\n   \n   /* set Destination PORT Number, 5000(0x1388) */\n   Sn_DPORTR[0:1] = {0x13, 0x88};\n   \n   /* set CONNECT Command */\n   Sn_CR = CONNECT;\n   while(Sn_CR != 0x00); /* wait until CONNECT Command is cleared*/\n   goto ESTABLISHED?;\n}\n")),(0,s.kt)("h4",{id:"established"},"ESTABLISHED?"),(0,s.kt)("p",null,'"TCP CLIENT" is in Sn',"_","SR (SOCK","_",'SYNSENT) until receiving SYN/ACK Packet\nfrom "TCP SERVER" against of SYN Packet transmitted. If SYN/ACK Packet\nis received from \u2018TCP SERVER\u2019, the Connection Process between \u2018TCP\nSERVER\u2019 and \u2018TCP CLIENT\u2019 is completed. If there is no response from Peer\nagainst of transmitted SYN Packet within the Retransmission Time, Sn',"_","IR\n","[","TIMEOUT","]"," is set to \u20181\u2019."),(0,s.kt)("h4",{id:"others-flow"},"Others flow"),(0,s.kt)("p",null,'Refer to "TCP SERVER" flow.'))}u.isMDXComponent=!0},4944:function(e,n,t){n.Z=t.p+"assets/images/tcp_client_flow-cb5d5605f2678cf3793303cd5e62e773.png"},43793:function(e,n,t){n.Z=t.p+"assets/images/server_flow-6cf61961e097a0578af9ed20276e28bd.jpg"},94024:function(e,n,t){n.Z=t.p+"assets/images/serverclient-908557ee7b67f55d5fb06eb580113be1.jpg"}}]);